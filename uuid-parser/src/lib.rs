// Copyright 2013-2014 The Rust Project Developers.
// Copyright 2018 The Uuid Project Developers.
//
// See the COPYRIGHT file at the top-level directory of this distribution.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! [`Uuid`] parsing constructs and utilities.
//!
//! [`Uuid`]: ../struct.Uuid.html

mod core_support;
#[cfg(feature = "std")]
mod std_support;

/// The expected value.
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Expected {
    /// Expected any one of the given values.
    Any(&'static [usize]),
    /// Expected the given value.
    Exact(usize),
    /// Expected any values in the given range.
    Range {
        /// The minimum expected value.
        min: usize,
        /// The maximum expected value.
        max: usize,
    },
}

/// An error that can occur while parsing a [`Uuid`] string.
///
/// [`Uuid`]: ../struct.Uuid.html
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ParseError {
    /// Invalid character in the [`Uuid`] string.
    ///
    /// [`Uuid`]: ../struct.Uuid.html
    InvalidCharacter {
        /// The expected characters.
        expected: &'static str,
        /// The invalid character found.
        found: char,
        /// The invalid character position.
        index: usize,
    },
    /// Invalid number of segments in the [`Uuid`] string.
    ///
    /// [`Uuid`]: ../struct.Uuid.html
    InvalidGroupCount {
        /// The expected number of segments.
        // TODO: explain multiple segment count.
        // BODY: Parsers can expect a range of Uuid segment count.
        //       This needs to be expanded on.
        expected: Expected,
        /// The number of segments found.
        found: usize,
    },
    /// Invalid length of a segment in a [`Uuid`] string.
    ///
    /// [`Uuid`]: ../struct.Uuid.html
    InvalidGroupLength {
        /// The expected length of the segment.
        expected: Expected,
        /// The length of segment found.
        found: usize,
        /// The segment with invalid length.
        group: usize,
    },
    /// Invalid length of the [`Uuid`] string.
    ///
    /// [`Uuid`]: ../struct.Uuid.html
    InvalidLength {
        /// The expected length(s).
        // TODO: explain multiple lengths.
        // BODY: Parsers can expect a range of Uuid lenghts.
        //       This needs to be expanded on.
        expected: Expected,
        /// The invalid length found.
        found: usize,
    },
}

impl ParseError {
    fn _description(&self) -> &str {
        match *self {
            ParseError::InvalidCharacter { .. } => "invalid character",
            ParseError::InvalidGroupCount { .. } => "invalid number of groups",
            ParseError::InvalidGroupLength { .. } => "invalid group length",
            ParseError::InvalidLength { .. } => "invalid length",
        }
    }
}

/// Check if the length matches any of the given criteria lengths.
pub fn len_matches_any(len: usize, crits: &[usize]) -> bool {
    for crit in crits {
        if len == *crit {
            return true;
        }
    }

    false
}

/// Check if the length matches any criteria lengths in the given range
/// (inclusive).
#[allow(dead_code)]
pub(crate) fn len_matches_range(len: usize, min: usize, max: usize) -> bool {
    for crit in min..(max + 1) {
        if len == crit {
            return true;
        }
    }

    false
}

// Accumulated length of each hyphenated group in hex digits.
pub const ACC_GROUP_LENS: [usize; 5] = [8, 12, 16, 20, 32];

// Length of each hyphenated group in hex digits.
pub const GROUP_LENS: [usize; 5] = [8, 4, 4, 4, 12];

// FIXME: This is less than ideal
const SIMPLE_LENGTH: usize = 32;
const HYPHENATED_LENGTH: usize = 36;
const URN_LENGTH: usize = 45;

/// Parses a `Uuid` from a string of hexadecimal digits with optional
/// hyphens.
///
/// Any of the formats generated by this module (simple, hyphenated, urn)
/// are supported by this parsing function.
pub fn parse_str(mut input: &str) -> Result<[u8; 16], ParseError> {
    // Ensure length is valid for any of the supported formats
    let len = input.len();

    if len == URN_LENGTH && input.starts_with("urn:uuid:") {
        input = &input[9..];
    } else if !len_matches_any(
        len,
        &[HYPHENATED_LENGTH, SIMPLE_LENGTH],
    ) {
        return Err(ParseError::InvalidLength {
            expected: Expected::Any(&[
                HYPHENATED_LENGTH,
                SIMPLE_LENGTH,
            ]),
            found: len,
        });
    }

    // `digit` counts only hexadecimal digits, `i_char` counts all chars.
    let mut digit = 0;
    let mut group = 0;
    let mut acc = 0;
    let mut buffer = [0u8; 16];

    for (i_char, chr) in input.bytes().enumerate() {
        if digit as usize >= SIMPLE_LENGTH && group != 4 {
            if group == 0 {
                return Err(ParseError::InvalidLength {
                    expected: Expected::Any(&[
                        HYPHENATED_LENGTH,
                        SIMPLE_LENGTH,
                    ]),
                    found: len,
                });
            }

            return Err(ParseError::InvalidGroupCount {
                expected: Expected::Any(&[1, 5]),
                found: group + 1,
            });
        }

        if digit % 2 == 0 {
            // First digit of the byte.
            match chr {
                // Calulate upper half.
                b'0'..=b'9' => acc = chr - b'0',
                b'a'..=b'f' => acc = chr - b'a' + 10,
                b'A'..=b'F' => acc = chr - b'A' + 10,
                // Found a group delimiter
                b'-' => {
                    // TODO: remove the u8 cast
                    // BODY: this only needed until we switch to
                    //       ParseError
                    if ACC_GROUP_LENS[group] as u8 != digit {
                        // Calculate how many digits this group consists of
                        // in the input.
                        let found = if group > 0 {
                            // TODO: remove the u8 cast
                            // BODY: this only needed until we switch to
                            //       ParseError
                            digit - ACC_GROUP_LENS[group - 1] as u8
                        } else {
                            digit
                        };

                        return Err(
                            ParseError::InvalidGroupLength {
                                expected: Expected::Exact(
                                    GROUP_LENS[group],
                                ),
                                found: found as usize,
                                group,
                            },
                        );
                    }
                    // Next group, decrement digit, it is incremented again
                    // at the bottom.
                    group += 1;
                    digit -= 1;
                }
                _ => {
                    return Err(ParseError::InvalidCharacter {
                        expected: "0123456789abcdefABCDEF-",
                        found: input[i_char..].chars().next().unwrap(),
                        index: i_char,
                    });
                }
            }
        } else {
            // Second digit of the byte, shift the upper half.
            acc *= 16;
            match chr {
                b'0'..=b'9' => acc += chr - b'0',
                b'a'..=b'f' => acc += chr - b'a' + 10,
                b'A'..=b'F' => acc += chr - b'A' + 10,
                b'-' => {
                    // The byte isn't complete yet.
                    let found = if group > 0 {
                        // TODO: remove the u8 cast
                        // BODY: this only needed until we switch to
                        //       ParseError
                        digit - ACC_GROUP_LENS[group - 1] as u8
                    } else {
                        digit
                    };

                    return Err(ParseError::InvalidGroupLength {
                        expected: Expected::Exact(
                            GROUP_LENS[group],
                        ),
                        found: found as usize,
                        group,
                    });
                }
                _ => {
                    return Err(ParseError::InvalidCharacter {
                        expected: "0123456789abcdefABCDEF-",
                        found: input[i_char..].chars().next().unwrap(),
                        index: i_char,
                    });
                }
            }
            buffer[(digit / 2) as usize] = acc;
        }
        digit += 1;
    }

    // Now check the last group.
    // TODO: remove the u8 cast
    // BODY: this only needed until we switch to
    //       ParseError
    if ACC_GROUP_LENS[4] as u8 != digit {
        return Err(ParseError::InvalidGroupLength {
            expected: Expected::Exact(GROUP_LENS[4]),
            found: (digit as usize - ACC_GROUP_LENS[3]),
            group,
        });
    }

    Ok(buffer)
}
